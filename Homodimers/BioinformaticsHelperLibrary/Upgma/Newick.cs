using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using BioinformaticsHelperLibrary.Misc;
using BioinformaticsHelperLibrary.Spreadsheets;

namespace BioinformaticsHelperLibrary.Upgma
{
    public static class Newick
    {

        //private static object _numThreadsLock = new object();
        //private static int _numThreads = 0;

        public static string TreeHeaderSafeName(string treeHeaderName)
        {
            return string.Join("", treeHeaderName.Select(c => char.IsLetterOrDigit(c) ? c : '_'));
        }

        /// <summary>
        /// Saves a Tree already generated by the NewickTreeFormat method.
        /// </summary>
        /// <param name="outputTreeFilename"></param>
        /// <param name="treeList"></param>
        /// <param name="fileExistsOptions"></param>
        /// <returns></returns>
        public static string SaveNewickTree(string outputTreeFilename, List<string> treeList, FileExistsHandler.FileExistsOptions fileExistsOptions = FileExistsHandler.FileExistsOptions.AppendNumberToFilename)
        {
            var filename = new FileInfo(FileAndPathMethods.RemoveFileExtension(outputTreeFilename) + ".tree");

            if (filename.Exists)
            {
                if (fileExistsOptions == FileExistsHandler.FileExistsOptions.AppendNumberToFilename)
                {
                    filename = new FileInfo(FileExistsHandler.FindNextFreeOutputFilename(filename.FullName));
                }
                else if (fileExistsOptions == FileExistsHandler.FileExistsOptions.OverwriteFile)
                {
                }
                else if (fileExistsOptions == FileExistsHandler.FileExistsOptions.SkipFile)
                {
                    return null;
                }
            }

            filename.Directory?.Create();

            File.WriteAllLines(filename.FullName, treeList);

            return filename.FullName;
        }

        private static string NewickTreeFormatStringRecursive(GenericNode node, List<string> treeLeafOrderList, List<string> vectorIndexesNames, decimal distanceOffsetToAdd, decimal parentDistance = 0, bool outputBranchNodeNames = false, bool outputLeafNodeNames = true, bool outputDistances = true, int recursionLevel = 0)
        {
            var nodeName = "";
            var distance = "";



            if (outputDistances) // && parentDistance != 0)
            {
                distance = ":" + decimal.Round(parentDistance + distanceOffsetToAdd, 5);
            }

            if (node.ParentList.Count == 0 || node.ParentList.Count(n => n != null && n.Node != null) == 0)
            {
                if (outputLeafNodeNames)
                {
                    nodeName = vectorIndexesNames[node.VectorIndexes[0]];

                    treeLeafOrderList.Add(nodeName);
                }

                return nodeName + distance;
            }

            if (outputBranchNodeNames)
            {
                nodeName = string.Join("_", node.VectorIndexes.Select(SpreadsheetFileHandler.AlphabetLetterRollOver).ToList());
            }

            var taskList = new List<Task<string>>();
            var localtreeLeafOrderLists = new List<List<string>>();

            string treeString = "";

            var nonTaskResults = new List<string>();

            for (var index = 0; index < node.ParentList.Count; index++)
            {
                var parentNode = node.ParentList[index];
                var localTreeLeafOrderList = new List<string>();
                localtreeLeafOrderLists.Add(localTreeLeafOrderList);

                if (recursionLevel < Environment.ProcessorCount)
                {
                    taskList.Add(Task.Run(() => NewickTreeFormatStringRecursive(parentNode.Node, localTreeLeafOrderList, vectorIndexesNames, distanceOffsetToAdd, parentNode.DistanceToNode, outputBranchNodeNames, outputLeafNodeNames, outputDistances, recursionLevel + 1)));
                }
                else
                {
                    nonTaskResults.Add(NewickTreeFormatStringRecursive(parentNode.Node, localTreeLeafOrderList, vectorIndexesNames, distanceOffsetToAdd, parentNode.DistanceToNode, outputBranchNodeNames, outputLeafNodeNames, outputDistances, recursionLevel + 1));
                }
            }
            if (recursionLevel < Environment.ProcessorCount)
            {

                Task.WaitAll(taskList.Where(t => !t.IsCompleted).ToArray<Task>());
            }

            var indexCap = recursionLevel < Environment.ProcessorCount ? taskList.Count : nonTaskResults.Count;

            for (var index = 0; index < indexCap; index++)
            {
                

                string result = "";
                if (recursionLevel < Environment.ProcessorCount)
                {
                    var task = taskList[index];
                    result = task.Result;
                }
                else
                {
                    result = nonTaskResults[index];
                }

                if (localtreeLeafOrderLists[index].Count > 0)
                {
                    lock (treeLeafOrderList)
                    {
                        treeLeafOrderList.AddRange(localtreeLeafOrderLists[index]);
                    }
                }

                if (index == 0)
                {
                    treeString += "(";
                }

                treeString += result;

                if (index != node.ParentList.Count - 1)
                {
                    treeString += ",";

                }
                else
                {
                    treeString += ")";
                }
            }

            treeString += nodeName + (recursionLevel > 0 ? distance : "");

            return treeString;
        }

        public static decimal MinimumNodeDistance(List<GenericNode> nodeList)
        {
            // find min distance to add to all distances in tree.
            var minDistance = 0m;

            foreach (var node in nodeList)
            {
                var searchList = new List<GenericNodeWithDistance>();
                searchList.AddRange(node.ParentList);
                searchList.AddRange(node.ChildrenList);

                foreach (var c in searchList)
                {
                    if (c.DistanceToNode != 0 && (minDistance == 0 || c.DistanceToNode < minDistance))
                    {
                        minDistance = c.DistanceToNode;
                    }
                }
            }

            return minDistance;
        }

        public static List<string> NewickTreeFormat(List<GenericNode> nodeList, List<string> names, out List<string> treeLeafOrderList, int minimumOutputTreeLeafs = 2)
        {
            var minDistance = 0; // = MinimumNodeDistance(nodeList);

            var rootNodeList = GenericNode.GetRootNodeList(nodeList);

            List<string> treeList = new List<string>();

            treeLeafOrderList = new List<string>();

            foreach (var rootNode in rootNodeList)
            {
                // check tree has at least minimumOutputTrees leafs

                var treeLeafs = rootNode.GetNodeTreeLeafs(nodeList);

                if (treeLeafs.Count >= minimumOutputTreeLeafs)
                {
                    treeList.Add(NewickTreeFormatStringRecursive(rootNode, treeLeafOrderList, names, minDistance) + ";");// + Environment.NewLine;
                }
            }

            return treeList;
        }
    }
}
